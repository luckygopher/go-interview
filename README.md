# go面试资料整理

### go语言基础
熟悉语法，撸个百十道基础面试题就差不多了。

### go语言进阶
CSP并发模型？
```markdown
CSP并发模型它并不关注发送消息的实体，而关注的是发送消息时使用的channel，
go语言借用了process和channel这两个概念，process表现为go里面的goroutine，
是实际并发执行的实体，每个实体之间是通过channel来进行匿名传递消息使之解藕，
从而达到通讯来实现数据共享。

不要通过共享内存来通信，而要通过通信来实现内存共享。

1、sync.mutex 互斥锁（获取锁和解锁可以不在同一个协程，当获取到锁之后，
未解锁，此时再次获取锁将会阻塞）
2、通过channel通信
3、sync.WaitGroup
```
GPM模型指的是什么？goroutine的调度时机有哪些？如果syscall阻塞会发生什么？
```markdown
在go中是通过channel通信来共享内存的。

G：指的是Goroutine，也就是协程，go中的协程做了优化处理，内存占用仅几kb
且调度灵活，切换成本低。
P：指的是processor,也就是处理器，感觉也可理解为协程调度器。
M：指的是thread，内核线程。

调度器的设计策略：
1、线程复用：当本线程无可运行的G时，M-P-G0会处于自旋状态，尝试从全局队列
获取G，再从其他线程绑定的P队列中偷取G，而不是销毁线程；当本线程因为G进行
系统调用阻塞时，线程会释放绑定的P队列，如果有空闲的线程可用就复用空闲的
线程，不然就创建一个新的线程来接管释放出来的P队列。
2、利用并行：GOMAXPROCS设置P的数量，最多有这么多个线程分布在多个cpu上
同时运行。
3、抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go
中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死。

go func的流程：
1、创建一个G，新建的G优先保存在P的本地队列中，如果满了则会保存到全局队列中。
2、G只能运行在M中，一个M必须持有一个P，M与P时1:1关系，M会从P的本地队列
弹出一个可执行状态的G来执行。
3、一个M调度G执行的过程是一个循环机制。
4、如果G阻塞，则M也会被阻塞，runtime会把这个线程M从P摘除，再创建或者
复用其他线程来接管P队列。
5、当G、M不在被阻塞，即系统调用结束，会先尝试找会之前的P队列，如果之前
的P队列已经被其他线程接管，那么这个G会尝试获取一个空闲的P队列执行，并放
入到这个P的本地队列。否则这个线程M会变成休眠状态，加入空闲线程队列，而G
则会被放入全局队列中。

M0：
M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，
不需要在heap上分配，M0负责执行初始化操作和启动第一个G，之后M0与其他的M一样。
G0：
G0是每次启动一个M都会第一个创建的goroutine，G0仅负责调度，不指向任何可执行
函数，每个M都会有一个自己的G0，在调度或者系统调用时会使用G0的栈空间，全局变量
的G0是M0的。

N:1-----出现阻塞的瓶颈，无法利用多个cpu
1:1-----跟多线程/多进程模型无异，切换协程代价昂贵
M:N-----能够利用多核，过于依赖协程调度器的优化和算法
```
channel底层的数据结构是什么？发送和接收元素的本质是什么？
```go
type hchan struct {
    qcount   uint           // *chan里元素数量
    dataqsiz uint           // *底层循环数组的长度，就是chan的容量
    buf      unsafe.Pointer // *指向大小为dataqsiz的数组，有缓冲的channel
    elemsize uint16         // chan中的元素大小
    closed   uint32         // chan是否被关闭的标志
    elemtype *_type         // chan中元素类型
    recvx    uint           // *当前可以接收的元素在底层数组索引(<-chan)
    sendx    uint           // *当前可以发送的元素在底层数组索引(chan<-)
    recvq    waitq          // 等待接收的协程队列(<-chan)
    sendq    waitq          // 等待发送的协程队列(chan<-)
    lock     mutex          // 互斥锁,保证每个读chan或者写chan的操作都是原子的
}

// waitq是sudog的一个双向链表，sudog实际上是对goroutine的一个封装。
type waitq struct {
	first *sudog
	last  *sudog
}

// channel的发送和接收操作本质上都是"值的拷贝"(并不是将指针"发送"到了chan里面，
// 只是拷贝它的值而已)，无论是从sender goroutine的栈到chan buf，还是
// 从chan buf到receiver goroutine，或者是直接从sender goroutine到receiver goroutine。

```
channel在哪些情况下会死锁/阻塞？
```markdown
1、一个无缓冲channel在一个主go程里同时进行读和写；
2、无缓冲channel在go程开启之前使用通道；
3、通道1中调用了通道2，通道2中调用了通道1；
4、读取空的channel；
5、超过channel缓存继续写入数据；
6、向已经关闭的channel中写入数据不会导致死锁，但会Panic异常。
```
那些类型不能作map的为key？map的key为什么是无序的？
```markdown
map的key必须可以比较，func、map、slice这三种类型不可比较，
只有在都是nil的情况下，才可与nil (== or !=)。因此这三种类型
不能作为map的key。

map的迭代顺序是不确定的，因为不同的哈希函数实现可能导致不同的遍历顺序，
map的顺序取决于所使用的哈希函数，随机哈希的目的是防止黑客使用哈希冲突的拒绝服务攻击。
```
map是线程安全的么？
```markdown
map在并发的情况下，只读是线程安全的，但同时读写是线程不安全的，sync.map是线程安全的。
```
map的底层实现原理是什么？
```markdown
在go中map是数组存储的，每个数组下标处存储的是一个bucket，每个bucket中
可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow
指针指向一个新的bucket，从而形成一个链表。
```
map的扩容过程是怎样的？

map的赋值过程和查找过程是怎样的？

如何解决hash冲突？

iface和eface的区别是什么？值接收者和指针接收者的区别？
```markdown
iface比eface中间多了一层itab结构，itab结构存储_type信息和[]func方法集。
```
接口的构造过程是怎样的？

context是什么？有什么作用？如何被取消？

go中的指针有什么限制？

slice的底层数据结构是怎样的？

你了解GC么？常见的GC实现方式有哪些？
```markdown
GC即垃圾回收机制：引用计数、三色标记法+混合写屏障机制
```
go的GC有那三个阶段？流程是什么？如果内存分配速度超过了标记清除速度怎么办？
```markdown
goV1.3之前采用的是普通标记清除，流程如下：
1、开始STW，暂停程序业务逻辑，找出不可达的对象和可达对象；
2、给所有可达对象做上标记；
3、标记完成之后，开始清除未标记的对象；
4、停止STW，让程序继续运行，然后循环重复这个过程，直到程序生命周期结束。

goV1.5三色标记法，流程如下：
1、只要是新创建的对象，默认的颜色都标记为白色；
2、每次GC回收开始，从根节点开始遍历所有对象，把遍历到的对象从白色集合
放入灰色集合；
3、遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色
对象放入黑色集合；
4、重复3中内容，直到灰色集合中无任何对象；
5、回收白色集合中的所有对象。

犹如剥洋葱一样，一层一层的遍历着色，但同时满足以下条件会导致对象丢失：
条件1：一个白色对象被黑色对象引用；
条件2：灰色对象与白色对象之间的可达关系同时被解除。

强三色：强制性的不允许黑色对象引用白色对象。
弱三色：黑色对象可以引用白色对象，但白色对象存在其他灰色对象对它的引用，或者
可达它的链路上游存在灰色对象。

goV1.8三色+混合写屏障机制，栈不启动屏障，流程如下：
1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行重复扫描，无需STW)；
2、GC期间，任何在栈上创建的新对象均标记为黑色；
3、被删除的对象和被添加的对象均标记为灰色；
4、回收白色集合中的所有对象。

总结：
v1.3普通标记清除法，整体过程需要STW，效率极低；
v1.5三色标记法+屏障，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描
一次栈(需要STW)，效率普通；
v1.8三色标记法+混合写屏障，堆空间启动，栈空间不启动屏障，整体过程几乎不需要STW,
效率较高。

如果申请内存的速度超过预期，运行时就会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，
在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。并发标记会
设置一个标志，并在mallocgc调用时进行检查，当存在新的内存分配时，会暂停分配内存过快
的哪些goroutine，并将其转去执行一些辅助标记的工作，从而达到放缓内存分配和加速GC工作
的目的。
```
内存泄漏是如何发生的，如何解决？

内存逃逸分析是怎么进行的？

### mysql
索引底层实现？为什么选择B+树作为索引结构？B+树的叶子节点都可以存哪些东西？

覆盖索引是什么？回表？

什么情况下不会命中索引？

mvvc的实现原理是什么？

redolog、undolog、binlog作用是什么？有什么区别？

乐观锁和悲观锁的实现方式？

事务隔离级别有哪些？如何解决脏读和幻读？

应该如何恰当的建立索引？

mysql的存储引擎有哪些？都有什么区别？

mysql的主从复制？

### 分布式系统、微服务架构
什么是分布式事务？

分布式事务解决方案有哪些？

分布式锁实现原理？有哪些实现方式？

微服务架构设计？

### kafka
kafka为什么性能高？

kafka重复消费可能的原因以及处理方式？

kafka消息丢失的原因以及解决方式？

kafka如何保证消息的顺序性？

什么是kafka的Rebalance？

kafka集群消息积压问题如何处理？

### redis
redis与memcached的区别？

redis单线程为什么效率也这么高？

redis有那五种常用的数据结构？应用场景以及实现原理是什么？

redis如何实现延迟队列？

redis的过期策略？

redis集群有那三种模式？

redis的事务？

redis与mysql双写一致性解决方案？

发生缓存穿透、击穿、雪崩的原因以及解决方案？

布隆过滤器的了解？

### 网络协议
浏览器访问一个网站，都经历了怎样一个流程？

什么是HTTP协议？

什么是HTTP报文？HTTP报文由那三部分组成？

HTTP常见的状态码有哪些？

HTTPS协议的底层原理是什么？

TCP协议和UDP协议有什么区别？

TCP协议的三次握手和四次挥手？为什么是三次和四次？

### 负载均衡
暂无

### 数据结构与算法
题目：将6，2，10，32，9，5，18，14，30，29从小到大进行排列,使用冒泡排序
```go
package main

import "fmt"

func main() {
    // 定义数组
    arr := [10]int{6, 2, 10, 32, 9, 5, 18, 14, 30, 29}
    for i := 0; i < len(arr); i++ {
        for j := 0; j < len(arr)-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    fmt.Println(arr)
}
```

快排

选择排序

堆排

### 区块链业务
暂无